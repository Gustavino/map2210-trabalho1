{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy import linalg\n",
    "import math\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_first_non_null_pivot(A, start):\n",
    "    \"\"\"  Iterate over the first column searching for a bigger than zero pivot  \"\"\"\n",
    "    pivot_row_index = start\n",
    "\n",
    "    for i in range(start, n):\n",
    "        if abs(A[i][start]) > 0.00001:\n",
    "            pivot_row_index = i\n",
    "            break\n",
    "\n",
    "    return pivot_row_index"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def backward_substitution(A):\n",
    "    n = len(A)\n",
    "    x = np.zeros(shape = n)\n",
    "    x[n-1] = A[n-1][n]/A[n-1][n-1]                              # STEP 8\n",
    "                                             \n",
    "    for i in range(n-2, -1, -1):                                     # STEP 9. Backward substitution.\n",
    "        print(\"entrooooooooooooooooooooooooooou\")\n",
    "        sum_axj = 0\n",
    "        for j in range(i, n-1):\n",
    "            sum_axj = (sum_axj + A[i][j]*x[j])\n",
    "        x[i] = (A[i][n] - sum_axj) / A[i][i]\n",
    "\n",
    "    return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gauss(A):                                                   # A is the augmented matrix\n",
    "    n = len(A)\n",
    "    print(A)\n",
    "    for i in range(0, n):                                       # STEP 1. i = i-th.\n",
    "        pivot_row_index = find_first_non_null_pivot(A, i)\n",
    "        print(pivot_row_index)\n",
    "\n",
    "        if abs(A[pivot_row_index][i]) < 0.00001:                # STEP 2. Is the pivot element equals to zero?.\n",
    "            print(\"no unique solution exists - 1\")\n",
    "            return 0\n",
    "\n",
    "        if (pivot_row_index != i):                              # STEP 3. Swaping rows.\n",
    "            A[[i, pivot_row_index]] = A[[pivot_row_index, i]]\n",
    "\n",
    "        for j in range(i+1, n):                                 # STEP 4.      \n",
    "            m = -A[j][i]/A[i][i]                                # STEP 5.\n",
    "            A[j] += m*A[i]                                      # STEP 6. Eliminating the first j-th elements.\n",
    "                                                                # A[j] means all columns of the j-th row of A.\n",
    "        print(A)\n",
    "\n",
    "\n",
    "    for k in range(0, n):                                       # STEP 7. Verifying if there is any zero in the main diagonal.\n",
    "        if abs(A[k][k]) < 0.00001:                              # Checking if A[k][k] is zero.\n",
    "            print(\"no unique solution exists - 2\")\n",
    "            return 0\n",
    "\n",
    "\n",
    "\n",
    "    # STARTING BACKWARD SUBSTITUTION\n",
    "    return backward_substitution(A)\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": "Please, enter the size n of the Hilbert matrix: \n[[1.         0.5        1.5       ]\n [0.5        0.33333333 0.83333333]]\n0\n[[1.         0.5        1.5       ]\n [0.         0.08333333 0.08333333]]\n1\n[[1.         0.5        1.5       ]\n [0.         0.08333333 0.08333333]]\n[0. 1.]\n"
    }
   ],
   "source": [
    "# Develop some main function\n",
    "\n",
    "n = 0\n",
    "while (n == 0):\n",
    "    print(\"Please, enter the size n of the Hilbert matrix: \")\n",
    "    n = int(input())\n",
    "hilbert_matrix = linalg.hilbert(int(n)) # Generating a nxn Hilbert matrix\n",
    "vector_b = np.array([hilbert_matrix[i].sum() for i in range (0, len(hilbert_matrix))]) # Generating vector b, the sum of Hilbert matrices rows\n",
    "vector_b = np.vstack(vector_b)\n",
    "\n",
    "augmented_hilbert_matrix = np.append(hilbert_matrix, vector_b, axis=1)\n",
    "\n",
    "vector_x = gauss(augmented_hilbert_matrix)\n",
    "print(vector_x)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5-final"
  },
  "orig_nbformat": 2,
  "kernelspec": {
   "name": "python37564bit146dc64882b0426e9bad50cbf0efb5c3",
   "display_name": "Python 3.7.5 64-bit"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}