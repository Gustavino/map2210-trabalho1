{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from scipy import linalg\n",
    "import math\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_first_non_null_pivot(A, start):\n",
    "    \"\"\"  Iterate over the first column searching for a bigger than zero pivot  \"\"\"\n",
    "    pivot_row_index = start\n",
    "\n",
    "    for i in range(start, n):\n",
    "        if abs(A[i][start]) > 0.00001:\n",
    "            pivot_row_index = i\n",
    "            break\n",
    "\n",
    "    return pivot_row_index"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [],
   "source": [
    "def backward_substitution(A):\n",
    "    n = len(A)\n",
    "    x = np.ones(shape = n)                                  \n",
    "                                             \n",
    "    for i in range(n-1, -1, -1):                                     # STEP 9. Backward substitution.\n",
    "        x[i] = A[i][n] / A[i][i]                                     # STEP 8\n",
    "        for j in range(i-1, -1, -1):\n",
    "            A[j][n] -= A[j][i] * x[i]\n",
    "\n",
    "\n",
    "    #A = np.delete(A, n, axis=1)\n",
    "    #print(A)\n",
    "    #print(np.linalg.det(A))\n",
    "    return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gauss(A):                                                   # A is the augmented matrix\n",
    "    n = len(A)\n",
    "\n",
    "    for i in range(0, n):                                       # STEP 1. i = i-th row.\n",
    "        pivot_row_index = find_first_non_null_pivot(A, i)\n",
    "\n",
    "        if abs(A[pivot_row_index][i]) < 0.00000000001:          # STEP 2. Checking if the pivot element is equals to zero.\n",
    "            print(\"no unique solution exists\")\n",
    "            return []\n",
    "\n",
    "        if (pivot_row_index != i):                              # STEP 3. Swaping rows if the pivot isn't in the main diagonal.\n",
    "            A[[i, pivot_row_index]] = A[[pivot_row_index, i]] ------------------------STEP 4 5 6\n",
    "\n",
    "        for k in range(i + 1, n):\n",
    "            c = -A[k][i] / A[i][i]\n",
    "            for j in range(i, n + 1):\n",
    "                if i == j:\n",
    "                    A[k][j] = 0\n",
    "                else:\n",
    "                    A[k][j] += c * A[i][j]\n",
    "\n",
    "    for k in range(0, n):                                       # STEP 7. Verifying if there is any zero in the main diagonal.\n",
    "        if abs(A[k][k]) < 0.00000000001:                              # Checking if A[k][k] is zero.\n",
    "            print(\"no unique solution exists\")\n",
    "            return []\n",
    "\n",
    "    # STARTING BACKWARD SUBSTITUTION\n",
    "    return backward_substitution(A)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {},
   "outputs": [
    {
     "output_type": "stream",
     "name": "stdout",
     "text": "O vetor resultante é [1. 1.], de ordem 2.\nO vetor resultante é [1. 1. 1. 1.], de ordem 4.\nO vetor resultante é [1. 1. 1. 1. 1. 1.], de ordem 6.\nO vetor resultante é [1.         1.         0.99999998 1.00000008 0.99999978 1.00000031\n 0.99999978 1.00000006], de ordem 8.\nO vetor resultante é [1.         1.00000013 0.99999725 1.00002476 0.99988301 1.00031909\n 0.99947997 1.00049964 0.99973902 1.00005714], de ordem 10.\nno unique solution exists\nO vetor resultante é 0, de ordem 12.\nno unique solution exists\nO vetor resultante é 0, de ordem 14.\n"
    }
   ],
   "source": [
    "# Develop some main function\n",
    "\n",
    "\n",
    "for n in range(2,16, 2):\n",
    "    hilbert_matrix = linalg.hilbert(int(n)) # Generating a nxn Hilbert matrix\n",
    "    vector_b = np.array([hilbert_matrix[i].sum() for i in range (0, len(hilbert_matrix))]) # Generating vector b, the sum of Hilbert matrices rows\n",
    "    vector_b = np.vstack(vector_b)\n",
    "    augmented_hilbert_matrix = np.append(hilbert_matrix, vector_b, axis=1)\n",
    "    vector_x = gauss(augmented_hilbert_matrix)\n",
    "    print(\"O vetor resultante é {}, de ordem {}.\".format(vector_x, n))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5-final"
  },
  "orig_nbformat": 2,
  "kernelspec": {
   "name": "python37564bit146dc64882b0426e9bad50cbf0efb5c3",
   "display_name": "Python 3.7.5 64-bit"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}